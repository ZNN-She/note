// pepe柯里化、compose组合、函数式编程、Pointfree概念

// pepe柯里化
var add = function(a) {
	return function(b) {
	  return a + b;
	}
}

console.log(add(1)(2));
const thenAdd = add(3);
console.log(thenAdd(4));
// 这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。
// 一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helper function）使这类函数的定义和调用更加容易。

function add(a, b){
	return a + b;
}
// 转柯粒化函数
function curry(fn){
	let limit = fn.length;
	return function temporaryFn(...args){
		if(args.length >= limit){
			return fn(...args);
		}else {
			return function(...args2){
				return temporaryFn(...args.concat(...args2))
			};
		}
	}
}
console.log(curry(add)(1, 2));
console.log(curry(add)(1)(2));
// 但是这里不能使用curry(add, 1, 2)这种形式调用，不过个人认为这也不符合柯粒化的调用方式

// 参考资料
// https://gitee.com/astonishqft/mostly-adequate-guide-chinese
// 纯函数要对所有依赖诚实，意味着所有的依赖参数都需要外部传入，这样就增加了函数参数的“复杂度”，在使用上会不会“复杂”？
// 参数也最小程度的给使用者足够的信息---知道用哪些数据，推到函数的用处
// 参数---强迫“注入”依赖
// 纯函数也具备很高的可移植性，因为理论上他不依赖任何函数外部的”副作用“
// 我们已经了解什么是纯函数了，也看到作为函数式程序员的我们，为何深信纯函数是不同凡响的。从这开始，我们将尽力以纯函数式的方式书写所有的函数。为此我们将需要一些额外的工具来达成目标，同时也尽量把非纯函数从纯函数代码中分离。
// 如果手头没有一些工具，那么纯函数程序写起来就有点费力。我们不得不玩杂耍似的通过到处传递参数来操作数据，而且还被禁止使用状态，更别说“作用”了。没有人愿意这样自虐。所以让我们来学习一个叫 curry 的新工具。
// todo 遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。到使用它们的时候你就明白这样做的原因是什么了。
// 当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。
// 哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。
// compose
// 组合像一系列"管道"那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。
// 我们认为组合是高于其他所有原则的设计原则，这是因为组合让我们的代码简单而富有可读性。另外范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。
// 我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。我敢保证，这种做法与那种需要时刻关心所有细节的命令式编程相比，会让你轻松许多。
// 与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。
// “声明式”---概念
// 声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。
// 因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。

// http://lucasmreis.github.io/blog/pointfree-javascript/
// http://www.ruanyifeng.com/blog/2017/03/pointfree.html
// https://fr.umio.us/favoring-curry/
// https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96
// https://www.ruanyifeng.com/blog/2017/03/ramda.html

// 函数提取没问题，但是函数提取总是伴随着大量的参数(分类扩展...)，柯里化是尽量用少的参数来达到效果吗？甚至才整个过程中没有直接使用到数据？
// 柯里化感觉最大的用处是复用，尽量拆成比较小、单一的函数，该函数不用关心数据和各种需要差异化的逻辑(如果需要差异化就把差异化在拆分)，
// 然后在使用的时候就是把这些单一函数组合起来

// Array.prototype.slice.call(arguments, 1); 为了获取第一个参数之后的所有参数，在arguments对象上调用了slice()方法，并传入参数1表示被返回的数组包含从第二个参数开始的所有参数